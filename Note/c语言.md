# *c语言

**低级语言**：**机器语言和汇编语言完全依赖于具体机器特性，是面向机器的语言，与具体机器距离很近。不同型号的机器语言和汇编语言是互不相通的。

**机器语言**：以16个二进制数（0 or 1）组成的指令，16个0和1可以组成各种排列组合，1011011000000000。这种计算机能够识别和接收的二进制代码称为**机器指令**

**符号语言（汇编语言）**：为克服机器语言的各种缺点，人们创造出符号语言，用英文字母和数字代表一个指令，同时需要一种称为“汇编程序”的软件，把符号语言转化为机器语言

| **汇编**：一条符号语言的指令对应转换为一条机器指令。转换的过程称为汇编。 |      |
| ------------------------------------------------------------ | ---- |
|                                                              |      |

**高级语言：**语言功能很强，且不依赖于具体机器，用它写出的程序对任何型号的计算机都适用，与具体机器距离较远，称为高级语言。

高级语言也需要翻译，用一种称为“编译程序”的软件把高级语言写的程序（叫做**源程序**）转换为机器指令的程序（**目标程序）**，然后让计算机执行机器指令程序，得到结果。高级语言的一个语句往往对应多个机器指令

 

**高级语言发展阶段：**

面向过程的语言：非结构化语言（阅读和维护困难）和结构化语言（由顺序结构，分支结构，循环结构构成）

缺点：编写程序时需要具体指定每一个过程的细节。在处理规模较大的程序时力不从心

**面向对象的语言**：c++，c#，Visual Basic 和Java。

简单程序：

```c
\# include <stdio.h>                                                //这是编译预处理指令

int main( )                                                     //定义主函数

{                                                                  //函数开始标志

​    printf (“This is a C program. \n");                 //输出指定的一行信息

​    return 0;                                                    //函数执行完毕时返回函数值0

}                                                                  //函数结束标志
```

在此简单程序中，**主函数是main，main前面的**int**表示**此函数类型是int类型（整型），**执行主函数后会得到一个函数值，叫做整型。

printf是C编译系统提供的函数库中的输出函数，**\n** **是换行符**，即输出信息后光标位置移到下一行开头。这个光标位置称为输出的当前位置，下一个输出的字符出现在此位置上。每个语句最后都有一个分号，表示结束。

stdio.h是系统提供的一个文件名，.h是文件后缀，表示头文件，输/入和输出函数的相关信息已事先放在stdio.h文件中。用# include指令把这些信息调入使用。（暂时所有模块开头均为# include <stdio.h>）。

**求两个整数之和**

```c
# include <stdio.h>

Int main( )

{

​     int a, b,sum;                        //本行为程序声明部分，定义a，b，sum为整数变量

​     a=123;

​     b=456;

​     sum=a+b;

​     printf("sum is %d\n",sum);       //输出结果

​    return 0;

}
```



"sum is %d\n"是输出格式字符串，作用是输出用户希望输出的格式。sum is是用户希望输出的字符，%d是指定输出格式，d表示"以十进制整数"形式输出。

注：在执行printf函数时，将sum变量的值（以十进制整数表示）取代“%d”。

所谓声明，就是告诉编译系统max是什么，以及它的有关信息。

在c语言中&是地址符，&a表示“变量a的地址”。执行scanf函数，从键盘读入两个整数，送到变量a和b的地址处，然后把这两个整数分别赋给变量a和b。

输入：scanf（"%d",&x）;

##### **注意：把a赋值给i时必须写成i=a，不能写成a=i，a=i表示把i赋值给a；

**备注：**a++和++a的区别：

a++先输出再赋值

++a先赋值再输出

比如a=1，a++=1

​                 ++a=2

同理，a=1，a--=1

​                    --a=0

a++运行会比++a运行略微慢一点。当数量级很大以后这个差别就会体现出来， 所以在不影响程序整体运行的情况下优先++a；

```
++a可以返回对象的引用，而a++一定要是返回对象的值。可想而知引用的开销当然比直接对对象进行操作要效率高很多，节省很多开销。因此执行代码++a的效率比a++要高.
```

运算符：

| 运算符 | 含义     |
| ------ | -------- |
| <      | 小于     |
| <=     | 小于等于 |
| ==     | 等于     |
| >      | 大于     |
| >=     | 大于等于 |
| !=     | 不等于   |

逻辑运算符：

| 逻辑运算符 | 含义                                                        |
| ---------- | ----------------------------------------------------------- |
| &&         | 与（当且当exp1和exp2都为真时，exp1&&exp2才为真）（一假必假) |
| \|\|       | 或（exp1或exp2有一个为真，exp1\|\|exp2为真）(一真必真）     |
| ！         | 非（若exp1为假，则!exp1为真，若exp1为真，则!exp1为假）      |

例子：6 > 2  && 3==3 真

​          ！（6>2 && 3==3）假

​          x！=0 &&（20 / x ）< 5 只有当x不等于0时，才会对第二个表达式求值

其它运算符：

**sizeof****运算符：**

sizeof是测量类型或变量长度的运算符

sizeof（short）《 sizeof（int）《s izeof（long）《 sizeof（long long）

比如查看当前系统中各类型的大小：

使用typesize.c程序：

```c
\#include<stdio.h>

{

​        printf("type **int** has a size of **%zd** bytes. \n",sizeof**(int**));

​        printf("type **cha**r has a size of **%zd** bytes. \n",sizeof**(char)**);

​        return 0;

}
```



**其它赋值运算符：**

**1.x+=20等价于x=x+20；**

**2.x-=20等价于x=x-20；**

**3.x*=20等价于x=x*20；**

**4.x/=20等价于x=x/20；**

**5.x%=3等价于x=x%3；**

#### **逗号运算符：**

逗号运算符是指在C语言中，多个表达式可以用逗号分开，其中用逗号分开的表达式的值分别结算，但整个表达式的值是最后一个表达式的值。

例子：

 

int a1,a2,b=2,c=7,d=5; // 第1行

a1=(++b,c--,d+3); // 第2行

a2=++b,c--,d+3; //第3行

**对于第二行，有括号，从左到右依次计算，但是因为有括号，所以只会把最后一个计算式的值赋给a1**

（注意：虽然只赋值最后一个计算式的值，但是其它两个计算式也会进行运算，只是不被赋值而已），

**第2行计算后，a1=d+3=8；b=3；c=6；**

对于第3行，没括号，仍旧从左到右依次计算，但是因为没有括号，所以把第一个计算式的值赋给a2(同a1的注意,后面的式子虽然不会赋值给a2，但仍然会计算），但是由于此时d+3无法赋值给任何变量，因此d+3不会进行运算；a=++b=4（第二行输出b=3）；c=5（第二行输出c=6）；d+3不作运算；

 

 

逗号运算符的应用：扩展了for的灵活性。比如：for（a=2，b=0；b<=1000;a++,b++);

 

 

 

三目运算：

对于条件表达式b ? x : y，先计算条件b，然后进行判断。如果b的值为true，计算x的值，运算结果为x的值；否则，计算y的值，运算结果为y的值。一个条件表达式绝不会既计算x，又计算y。条件运算符是右结合的，也就是说，从右向左分组计算。例如，a ? b : c ? d : e将按a ? b : (c ? d : e)执行。

 

可以这么理解：该条件是否成立？true执行算法1；false 执行算法2；

 **const：**

**修饰局部变量**

const int n=5;

int const n=5;

**这两种写法是一样的**，都是表示变量n的值不能被改变了，需要注意的是，**用const修饰变量时，一定要给变脸初始化**，否则之后就不能再进行赋值了。如果之后试图更改变量n的值，程序就会报错

 

 

 

**if（x）等价于if（x！=0）**

**例子：**

```c
If(year%4==0)
  {
  if(year%100==0)
  {
​   if(year%100==0)
​   leap=1;
​     else
    leap=0;
​     }else 
      leap=1;
​      }else 
    leap=0;

If(leap)        [\\这里等价于if（leap!=0)用于判断leap的真假]

​          printf("%d is",year);

Else 

​          printf(%d is not",year)
```



 

**用switch语句实现多分支选择结构**

switch（控制表达式）{           [\\控制表达式必须是整数型，即表达式必须是int](file://控制表达式必须是整数型，即表达式必须是int)；

case 常量：       [\\当控制表达式等于该常量时执行下面的语句](file://当控制表达式等于该常量时执行下面的语句)

​       语句

​      ……

​      break            [\\注意在一般情况下，在执行一个case子句后面要用break语句使流程跳出switch结构，即终止switch语句的执行](file://注意在一般情况下，在执行一个case子句后面要用break语句使流程跳出switch结构，即终止switch语句的执行)

case  常量

​        语句

​       ……

​       break

default：      [\\表示当表达式不符合以上所有条件时执行一下语句](file://表示当表达式不符合以上所有条件时执行一下语句)

语句

……

}

 

 

**用break语句提前终止循环**

```c
例子：int a，b，i；

for（i=1；i《1000；++i）

{

​        b=300；

​        a=b+i；

​        if（a》700）break；     [\\当a大于等于700时结束整个循环](file://当a大于等于700时结束整个循环)

}
```



for（i=1；i《1000；++i）

{

​        b=300；

​        a=b+i；

​        if（a》700）break；     [\\当a大于等于700时结束整个循环](file://当a大于等于700时结束整个循环)

}

 

**用continue语句提前结束本次循环**

**continue所用的位置与break相同，功能也基本相同，只不过****continue****是跳过这次循环，直接开始下次循环，可用于在循环过程中去除不符合条件的结果**

例子：

```c
\#include<stdio.h>

int main()

{

int a;

for(a=100;a<200;++a)

{

if(a%3==0)

 continue;   [\\当a能整除3时跳过本次循环直接开始下一循环](file://当a能整除3时跳过本次循环直接开始下一循环)

 printf("%d \n",a);

}

return 0;

 } 
```

